#!/usr/bin/env node
import postgres from 'postgres';
import fs from 'fs';
import path from 'path';
import {fileURLToPath} from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// POSTGRES -> TYPESCRIPT MAP
const TYPE_MAP: Record<string, string> = {
    text: 'string',
    varchar: 'string',
    char: 'string',
    uuid: 'string',
    int2: 'number',
    int4: 'number',
    int8: 'number',
    float4: 'number',
    float8: 'number',
    numeric: 'number',
    bool: 'boolean',
    json: 'any',
    jsonb: 'any',
    date: 'string',
    timestamp: 'string',
    timestamptz: 'string',
    bytea: 'Buffer',
    _text: 'string[]',
    _int4: 'number[]',
    _uuid: 'string[]'
};

function parseArgs() {
    const args = process.argv.slice(2);
    const config: Record<string, string> = {};

    for (let i = 0; i < args.length; i++) {
        const arg = args[i];
        if (arg.startsWith('--')) {
            const key = arg.replace(/^--/, '');
            if (key.includes('=')) {
                const [k, v] = key.split('=');
                config[k] = v;
            } else if (args[i + 1] && !args[i + 1].startsWith('--')) {
                config[key] = args[i + 1];
                i++;
            }
        }
    }
    return config;
}

// HELPER: Find the project root (where package.json is)
function findProjectRoot(startDir: string): string {
    let currentDir = startDir;
    while (currentDir !== path.parse(currentDir).root) {
        if (fs.existsSync(path.join(currentDir, 'package.json'))) {
            return currentDir;
        }
        currentDir = path.dirname(currentDir);
    }
    return startDir; // Fallback to current if not found
}

async function generate() {
    const args = parseArgs();
    let sql: postgres.Sql;

    console.log("üîÆ Kinetic SQL: Introspecting Database...");

    const connString = args.connection || process.env.DATABASE_URL;

    if (connString) {
        sql = postgres(connString, {max: 1});
    } else if (args.host || args.user || args.db) {
        sql = postgres({
            host: args.host || 'localhost',
            port: Number(args.port) || 5432,
            user: args.user || 'postgres',
            password: args.password || '',
            database: args.db || 'postgres',
            max: 1
        });
    } else {
        console.error("‚ùå Error: No connection details found.");
        process.exit(1);
    }

    try {
        const columns = await sql`
            SELECT table_name, column_name, udt_name, is_nullable
            FROM information_schema.columns
            WHERE table_schema = 'public'
            ORDER BY table_name, ordinal_position;
        `;

        const functions = await sql`
            SELECT p.proname                        as function_name,
                   pg_get_function_arguments(p.oid) as args_raw,
                   t.typname                        as return_type
            FROM pg_proc p
                     JOIN pg_type t ON p.prorettype = t.oid
                     JOIN pg_namespace n ON p.pronamespace = n.oid
            WHERE n.nspname = 'public';
        `;

        const tables: Record<string, string[]> = {};

        for (const col of columns) {
            if (!tables[col.table_name]) tables[col.table_name] = [];
            const tsType = TYPE_MAP[col.udt_name] || 'any';
            const nullable = col.is_nullable === 'YES' ? '| null' : '';
            tables[col.table_name].push(
                `                ${col.column_name}: ${tsType}${nullable};`
            );
        }

        let content = `// Auto-generated by Kinetic SQL ‚ö†Ô∏è Do NOT import this file manually.\n\nimport 'kinetic-sql';\n\ndeclare module 'kinetic-sql' {\n    export interface Register {\n        schema: {\n            tables: {\n`;

        for (const [tableName, cols] of Object.entries(tables)) {
            content += `            ${tableName}: {\n${cols.join('\n')}\n            };\n`;
        }

        content += `            };\n            functions: {\n`;

        for (const fn of functions) {
            content += `                ${fn.function_name}: {\n                    args: Record<string, any>;\n                    returns: any;\n                };\n`;
        }

        content += `            };\n        };\n    }\n}\n`;

        // CORRECT PATH LOGIC: Always find project root, then look for src
        const projectRoot = findProjectRoot(process.cwd());
        const outputPath = path.resolve(projectRoot, 'src', 'kinetic-env.d.ts');

        const dir = path.dirname(outputPath);
        if (!fs.existsSync(dir)) fs.mkdirSync(dir, {recursive: true});

        fs.writeFileSync(outputPath, content);
        console.log(`‚úÖ Generated types at: ${outputPath}`);

    } catch (err) {
        console.error("‚ùå Generation failed:", err);
    } finally {
        await sql.end();
    }
}

generate().then(() => console.log(`Auto-complete types generated successfully ‚ú®`));
