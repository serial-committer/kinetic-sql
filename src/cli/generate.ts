import postgres from 'postgres';
import fs from 'fs';
import path from 'path';
import {fileURLToPath} from 'url';

// Handling __dirname in ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// POSTGRES -> TYPESCRIPT MAP
const TYPE_MAP: Record<string, string> = {
    text: 'string',
    varchar: 'string',
    char: 'string',
    uuid: 'string',
    int2: 'number',
    int4: 'number',
    int8: 'number',
    float4: 'number',
    float8: 'number',
    numeric: 'number',
    bool: 'boolean',
    json: 'any',
    jsonb: 'any',
    date: 'string',
    timestamp: 'string',
    timestamptz: 'string',
    bytea: 'Buffer',
    _text: 'string[]',
    _int4: 'number[]',
    _uuid: 'string[]'
};

async function generate() {
    console.log("üîÆ Kinetic SQL: Introspecting Database...");

    const connectionString = process.env.DATABASE_URL;
    if (!connectionString) {
        console.error("‚ùå Error: DATABASE_URL is not set.");
        process.exit(1);
    }

    const sql = postgres(connectionString, {max: 1});

    try {
        // 1. FETCH TABLE COLUMNS
        const columns = await sql`
            SELECT table_name, column_name, udt_name, is_nullable
            FROM information_schema.columns
            WHERE table_schema = 'public'
            ORDER BY table_name, ordinal_position;
        `;

        // 2. FETCH RPC FUNCTIONS
        // This query finds user-defined functions in public schema
        const functions = await sql`
            SELECT p.proname                        as function_name,
                   pg_get_function_arguments(p.oid) as args_raw,
                   t.typname                        as return_type
            FROM pg_proc p
                     JOIN pg_type t ON p.prorettype = t.oid
                     JOIN pg_namespace n ON p.pronamespace = n.oid
            WHERE n.nspname = 'public';
        `;

        // --- CODE GENERATION ---

        const tables: Record<string, string[]> = {};

        // Process Tables
        for (const col of columns) {
            if (!tables[col.table_name]) tables[col.table_name] = [];

            const tsType = TYPE_MAP[col.udt_name] || 'any';
            const nullable = col.is_nullable === 'YES' ? '| null' : '';

            tables[col.table_name].push(
                `                ${col.column_name}: ${tsType}${nullable};`
            );
        }

        // Generate File Content
        // We use "declare module" to inject these types into the library
        let content = `// Auto-generated by Kinetic SQL ‚ö†Ô∏è Do NOT import this file manually. It automatically patches the library.

import 'kinetic-sql';

declare module 'kinetic-sql' {
    export interface Register {
        schema: {
            tables: {
`;

        // Write Tables
        for (const [tableName, cols] of Object.entries(tables)) {
            content += `            ${tableName}: {\n${cols.join('\n')}\n            };\n`;
        }

        content += `            };\n            functions: {\n`;

        // Write Functions (Simplified Args for MVP)
        for (const fn of functions) {
            // Note: A robust implementation would parse "args_raw" (e.g. "x int, y text")
            // into { x: number, y: string }.
            // For now, we use Record<string, any> to avoid regex complexity errors.
            content += `                ${fn.function_name}: {\n`;
            content += `                    args: Record<string, any>;\n`;
            content += `                    returns: any;\n`;
            content += `                };\n`;
        }

        content += `            };\n        };\n    }\n}\n`;

        // 3. WRITE FILE
        // We assume the user runs this from their project root
        const outputPath = path.resolve(process.cwd(), 'src', 'kinetic-env.d.ts');

        // Ensure directory exists
        const dir = path.dirname(outputPath);
        if (!fs.existsSync(dir)) fs.mkdirSync(dir, {recursive: true});

        fs.writeFileSync(outputPath, content);

        console.log(`‚úÖ Generated types at: ${outputPath}`);

    } catch (err) {
        console.error("‚ùå Generation failed:", err);
    } finally {
        await sql.end();
    }
}

generate().then(() => console.log(`Process Complete.`));
